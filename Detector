local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "HighRealmsDetectorGUI"
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0.25, 0, 0.35, 0)
mainFrame.Position = UDim2.new(0.375, 0, 0.325, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.ClipsDescendants = true
mainFrame.Parent = screenGui

local uiCornerMain = Instance.new("UICorner")
uiCornerMain.CornerRadius = UDim.new(0, 10)
uiCornerMain.Parent = mainFrame

local uiStrokeMain = Instance.new("UIStroke")
uiStrokeMain.Thickness = 1
uiStrokeMain.Parent = mainFrame

local headerFrame = Instance.new("Frame")
headerFrame.Name = "HeaderFrame"
headerFrame.Size = UDim2.new(1, 0, 0.2, 0)
headerFrame.Position = UDim2.new(0, 0, 0, 0)
headerFrame.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
headerFrame.Parent = mainFrame

local uiCornerHeader = Instance.new("UICorner")
uiCornerHeader.CornerRadius = UDim.new(0, 10)
uiCornerHeader.Parent = headerFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Text = "High Realms"
titleLabel.TextScaled = true
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.BackgroundTransparency = 1
titleLabel.Size = UDim2.new(0.85, 0, 1, 0)
titleLabel.Position = UDim2.new(0.1, 0, 0, 0)
titleLabel.TextXAlignment = Enum.TextXAlignment.Center
titleLabel.TextYAlignment = Enum.TextYAlignment.Center
titleLabel.Parent = headerFrame

local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Text = "X"
closeButton.TextScaled = true
closeButton.TextColor3 = Color3.fromRGB(255, 0, 0)
closeButton.BackgroundTransparency = 1
closeButton.Size = UDim2.new(0.1, 0, 1, 0)
closeButton.Position = UDim2.new(0.9, 0, 0, 0)
closeButton.Font = Enum.Font.GothamBold
closeButton.Parent = headerFrame

local itemButton = Instance.new("TextButton")
itemButton.Name = "ItemButton"
itemButton.Text = "Item"
itemButton.TextScaled = true
itemButton.TextColor3 = Color3.fromRGB(255, 255, 255)
itemButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
itemButton.Size = UDim2.new(0.8, 0, 0.12, 0)
itemButton.Position = UDim2.new(0.1, 0, 0.25, 0)
itemButton.Font = Enum.Font.GothamBold
itemButton.Parent = mainFrame

local uiCornerItem = Instance.new("UICorner")
uiCornerItem.CornerRadius = UDim.new(0, 8)
uiCornerItem.Parent = itemButton

local mobButton = Instance.new("TextButton")
mobButton.Name = "MobButton"
mobButton.Text = "Mob"
mobButton.TextScaled = true
mobButton.TextColor3 = Color3.fromRGB(255, 255, 255)
mobButton.BackgroundColor3 = Color3.fromRGB(255, 128, 0)
mobButton.Size = UDim2.new(0.8, 0, 0.12, 0)
mobButton.Position = UDim2.new(0.1, 0, 0.39, 0)
mobButton.Font = Enum.Font.GothamBold
mobButton.Parent = mainFrame

local uiCornerMob = Instance.new("UICorner")
uiCornerMob.CornerRadius = UDim.new(0, 8)
uiCornerMob.Parent = mobButton

local badgeButton = Instance.new("TextButton")
badgeButton.Name = "BadgeButton"
badgeButton.Text = "Badge"
badgeButton.TextScaled = true
badgeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
badgeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
badgeButton.Size = UDim2.new(0.8, 0, 0.12, 0)
badgeButton.Position = UDim2.new(0.1, 0, 0.53, 0)
badgeButton.Font = Enum.Font.GothamBold
badgeButton.Parent = mainFrame

local uiCornerBadge = Instance.new("UICorner")
uiCornerBadge.CornerRadius = UDim.new(0, 8)
uiCornerBadge.Parent = badgeButton

local questButton = Instance.new("TextButton")
questButton.Name = "QuestButton"
questButton.Text = "Quest"
questButton.TextScaled = true
questButton.TextColor3 = Color3.fromRGB(255, 255, 255)
questButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
questButton.Size = UDim2.new(0.8, 0, 0.12, 0)
questButton.Position = UDim2.new(0.1, 0, 0.67, 0)
questButton.Font = Enum.Font.GothamBold
questButton.Parent = mainFrame

local uiCornerQuest = Instance.new("UICorner")
uiCornerQuest.CornerRadius = UDim.new(0, 8)
uiCornerQuest.Parent = questButton

local dragging = false
local dragStart = nil
local startPos = nil

mainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

mainFrame.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

itemButton.MouseButton1Click:Connect(function()
local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local blockDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Block"):WaitForChild("DefinitionModules"):WaitForChild("Blocks")

local underlingAnchors = blockDefinitionModules:FindFirstChild("Ore Blocks")
if underlingAnchors then
    underlingAnchors.Name = "OreBlocks"
else
end
wait("2")
local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local blockDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Block"):WaitForChild("DefinitionModules")

local underlingAnchors = blockDefinitionModules:FindFirstChild("Underling Anchors")
if underlingAnchors then
    underlingAnchors.Name = "UnderlingAnchors"
else
end
wait("2")

local sections = {
    Axe = "CommonModules.DefinitionModules.Tool.DefinitionModules.Axe",
    Hoe = "CommonModules.DefinitionModules.Tool.DefinitionModules.Hoe",
    Misc = "CommonModules.DefinitionModules.Tool.DefinitionModules.Misc",
    Pickaxe = "CommonModules.DefinitionModules.Tool.DefinitionModules.Pickaxe",
    Scythe = "CommonModules.DefinitionModules.Tool.DefinitionModules.Scythe",
    Swords = "CommonModules.DefinitionModules.Tool.DefinitionModules.Swords",
    Food = "CommonModules.DefinitionModules.Food.DefinitionModules",
    Item = "CommonModules.DefinitionModules.Item.DefinitionModules",
    Store = "CommonModules.DefinitionModules.Store.DefinitionModules",
    Block = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks",
    Chests = "CommonModules.DefinitionModules.Block.DefinitionModules.Chests",
    Crops = "CommonModules.DefinitionModules.Block.DefinitionModules.Crops",
    Trees = "CommonModules.DefinitionModules.Block.DefinitionModules.Trees",
    UnderlingAnchors = "CommonModules.DefinitionModules.Block.DefinitionModules.UnderlingAnchors",
    Carpet = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Carpet",
    Clay = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Clay",
    Creator = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Creator",
    Doors = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Doors",
    Fence = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Fence",
    Flowers = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Flowers",
    Furniture = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Furniture",
    Glass = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Glass",
    Leaves = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Leaves",
    Neon = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Neon",
    OreBlocks = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.OreBlocks",
    Slabs = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Slabs",
    Stairs = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Stairs",
    Wood = "CommonModules.DefinitionModules.Block.DefinitionModules.Blocks.Wood"
 }

local knownItems = {
    Axe = {
        "Cobalt Axe", "Copper Axe", "Gold Axe", "Iron Axe", "Wood Axe", "Stone Axe"
    },
    Hoe = {
        "Wood Hoe"
    },
    Misc = {
        "Player Pickaxe", "Joke Axe"
    },
    Pickaxe = {
        "Wood Pickaxe", "Cobalt Pickaxe", "Stone Pickaxe", "Iron Pickaxe", "Gold Pickaxe", "Copper Pickaxe"
    },
    Scythe = {
        "Iron Scythe", "Gold Scythe"
    },
    Swords = {
        "Bone Sword", "Clockwork Sword", "Cobalt Sword", "Copper Sword", "Gold Sword", "Inferno Sword", "Iron Sword", "Slime Sword", "Stone Sword", "Twilight Sword", "Wood Sword", "Dev Sword"
    },
    Food = {
        "Carrot", "Corn", "White Mushroom", "Red Potato", "Tomato", "Strawberry", "Watermelon", "Wheat"
    },
    Item = {
        "Void Shard", "Black Dye", "Blue Dye", "Spring", "Twilight Blade", "Bones", "Skull", "Skeleton Key", "Silver", "Cog", "Coal", "Basalt", "Molten Core", "Inferno Essence", "Light Source", "Scrap Metal", "Flame", "Copper", "Cobalt", "Elastic Essence", "Yellow Dye", "Stone", "Necrotic Essence", "Gold", "Green Dye", "Green Goo", "Green Slime Core", "Iron", "Magnet Shard", "Marble", "Twilight Essence", "White Dye", "Rage Essence", "Realm Key", "Recycled Blade", "Red Dye", "Clay", "Cloth", "Mystic Iron Fragment", "Mystic Gold Fragment"
    },
    Store = {
        "Theme Pink", "Dragon Storage Chest Product", "Pro Backpack", "Island Expansion", "5,000 Coins Pack", "100,000 Coins Pack", "25,000 Coins Pack", "Island Flight", "Theme Storm", "Theme Crimson", "Theme Ancient", "1,000 Coins Pack"
    },
    Block = {
        "Grass", "Dirt", "Stone Block", "Marble Brick Block", "Silver Block", "Bedrock", "Basalt Block", "Cobblestone", "Marble Block", "Pink Stone Brick Block", "Lantern Block", "SpiderWeb", "Slime Block", "Ladder", "Tilled Dirt", "Torch", "Pink Grass", "Coal Block", "Cobalt Block", "Copper Block", "Fire Block", "Gold Block", "Iron Block", "Grass Weed", "Vines", "Wood Table", "Wooden Crate", "Wall Torch", "Danger Sign", "Electric FX Block", "Fog FX Block", "Rain FX Block", "Crimson Ornate Block", "Sword Throne", "Crimson Grass Block", "Crimson Moss Block", "Jungle Vines", "Jungle Grass Block", "Jungle Moss Block", "Tiki Head Block", "Tiki Pole Block", "Basalt Slab", "Stone Brick Block", "Red Brick Block", "Red Brick Slab", "Hay Bale", "Red Brick Vertical Slab", "Basalt Vertical Slab", "Spotlight", "Candles", "Hanging Lantern", "Wood Chair", "Wood Barrel", "Workbench"
    },
    Chests = {
        "Dragonstone Chest", "Large Chest", "Small Chest"
    },
    Crops = {
        "White Mushroom Seed", "Wheat Seed", "Watermelon Seed", "Tomato Seed", "Strawberry Seed", "Red Potato Seed", "Corn Seed", "Carrot Seed"
    },
    Trees = {
        "AshTreeA", "AshTreeB", "CherryTreeA", "CherryTreeB", "DarkHollowTallTreeA", "DarkHollowTallTreeB", "DarkHollowTallTreeC", "DarkHollowTallTreeD", "DarkHollowTallTreeE", "DarkHollowTreeA", "DarkHollowTreeB", "DarkHollowTreeC", "DarkHollowTreeD", "DarkHollowTreeE", "MahoganyTreeA", "MahoganyTreeB", "OakTreeA", "OakTreeB", "OakTreeC", "OakTreeD", "OakTreeE"
    },
    UnderlingAnchors = {
        "Carrot Underling Anchor", "Oak Wood Underling Anchor", "Mahogany Wood Underling Anchor", "Cobalt Underling Anchor", "Watermelon Underling Anchor", "Dark Hollow Wood Underling Anchor", "Basalt Underling Anchor", "Clay Underling Anchor", "Coal Underling Anchor", "Gold Underling Anchor", "Copper Underling Anchor", "Iron Underling Anchor", "Ash Wood Underling Anchor", "Corn Underling Anchor", "Silver Underling Anchor", "Red Potato Underling Anchor", "Tomato Underling Anchor", "Strawberry Underling Anchor", "White Mushroom Underling Anchor", "Cherry Wood Underling Anchor", "Stone Underling Anchor", "Wheat Underling Anchor", "Marble Underling Anchor"
    },
    Carpet = {
        "Carpet Lime", "Carpet Brown", "Carpet Blue", "Carpet Grey", "Carpet Orange", "Carpet Red", "Carpet Light Blue", "Carpet Black", "Carpet Green", "Carpet Purple", "Carpet Yellow", "Carpet White", "Carpet Pink", "Carpet Cyan"
    },
    Clay = {
        "Clay White", "Clay Purple", "Clay Yellow", "Clay Light Blue", "Clay Block", "Clay Brown", "Clay Pink", "Clay Black", "Clay Lime", "Clay Orange", "Clay Red", "Clay Vase", "Clay Green", "Clay Cyan", "Clay Blue"
    },
    Creator = {
        "Sisterguard Block", "DV Block", "TanqR Block", "Jessetc Block", "Hoopie Block", "Gravycatman Block", "Witchycatlady Block"
    },
    Doors = {
        "Mahogany Trap Door", "Dark Hollow Door", "Mahogany Door", "Dark Hollow Trap Door", "Ash Door", "Oak Door", "Cherry Trap Door", "Cherry Door", "Ash Trap Door", "Oak Trap Door"
    },
    Fence = {

    },
    Flowers = {
        "Pink Potted Flower", "Green Poppy Flower", "Yellow Poppy Flower", "White Poppy Flower", "Yellow Potted Flower", "Blue Poppy Flower", "Blue Potted Flower", "White Potted Flower", "Red Potted Flower", "Purple Potted Flower", "Red Poppy Flower", "Cyan Potted Flower", "Black Poppy Flower"
    },
    Furniture = {
        "Wood Stool", "Teal Table Lamp", "Red Bed", "Campfire", "Yellow Bed", "Tumbler", "Blue Bed", "Red Table Lamp", "Light Blue Bed", "Teal Luxury Sofa", "Black Bed", "Purple Bed", "Brown Bed", "Sofa Section Corner", "Tall Lamp", "Gold Table Lamp", "Large Umbrella", "Sofa Section Basic", "Lime Bed", "Sofa Section", "Cyan Bed", "Nightstand", "Orange Bed", "Pink Bed", "Plate Set", "Red Royal Bed", "Metal Grate", "Mug", "Grey Table Lamp", "Bookcase", "Green Bed"
    },
    Glass = {
        "Glass Brown", "Glass", "Glass Pink", "Glass Lime", "Glass Black", "Glass Red", "Glass White", "Glass Green", "Glass Cyan", "Glass Yellow", "Glass Light Blue", "Glass Blue", "Glass Purple", "Glass Orange"
    },
    Leaves = {
        "Mahogany Leaves", "Oak Leaves", "Dark Hollow Leaves", "Cherry Leaves", "Ash Leaves"
    },
    Neon = {
        "Neon Cyan", "Neon Red", "Neon Green", "Neon Pink", "Neon Yellow", "Neon Black", "Neon Purple", "Neon White", "Neon Blue", "Neon Orange", "Neon Light Blue", "Neon Lime"
    },
    OreBlocks = {
        "Clay Mud Block", "Basalt Rock Block", "Cobalt Ore Block", "Coal Ore Block", "Iron Ore Block", "Copper Ore Block", "Gold Ore Block", "Stone Rock Block", "Silver Ore Block", "Marble Rock Block"
    },
    Slabs = {
        "Stone Slab", "Mahogany Vertical Slab", "Marble Brick Slab", "Pink Stone Brick Slab", "Oak Vertical Slab", "Stone Brick Slab", "Oak Slab", "Cherry Vertical Slab", "Dark Hollow Vertical Slab", "Marble Brick Vertical Slab", "Dark Hollow Slab", "Stone Vertical Slab", "Stone Brick Vertical Slab", "Pink Stone Brick Vertical Slab", "Cherry Slab", "Ash Vertical Slab", "Ash Slab", "Mahogany Slab"
    },
    Stairs = {
        "Oak Stair", "Stone Brick Stair", "Red Brick Stair", "Stone Stair", "Dark Hollow Stair", "Basalt Stair", "Marble Brick Stair", "Cherry Stair", "Pink Stone Brick Stair", "Mahogany Stair", "Ash Stair"
    },
    Wood = {
        "Dark Hollow Wood", "Ash Wood", "Oak Plank", "Mahogany Plank", "Cherry Wood", "Mahogany Wood", "Oak Wood", "Ash Plank", "Cherry Plank", "Dark Hollow Plank"
    }
}

local function getObjectByPath(root, path)
    local current = root
    for segment in string.gmatch(path, "[^.]+") do
        current = current:FindFirstChild(segment)
        if not current then
            warn("Could not find: " .. segment .. " in path: " .. path)
            return nil
        end
    end
    return current
end

local clipboardOutput = ""
local newItemsOutput = ""
local newItemsFound = false

for sectionName, path in pairs(sections) do
    local section = getObjectByPath(replicatedStorage, path)
    local knownItemsSet = {}
    local newItems = {}
    
    if knownItems[sectionName] then
        for _, itemName in ipairs(knownItems[sectionName]) do
            knownItemsSet[itemName] = true
        end
    end
    
    if section then
        clipboardOutput = clipboardOutput .. "----- " .. sectionName .. " -----\n"
        local hasModules = false
        
        for _, moduleScript in pairs(section:GetChildren()) do
            if moduleScript:IsA("ModuleScript") then
                local moduleName = moduleScript.Name
                clipboardOutput = clipboardOutput .. moduleName .. "\n"
                hasModules = true
                
                if not knownItemsSet[moduleName] then
                    newItems[moduleName] = true
                    newItemsFound = true
                end
            end
        end
        
        if not hasModules then
            clipboardOutput = clipboardOutput .. "No ModuleScripts found in " .. sectionName .. "\n"
        end
    end
    
    if next(newItems) then
        newItemsOutput = newItemsOutput .. "----- New Items in " .. sectionName .. " -----\n"
        for itemName in pairs(newItems) do
            newItemsOutput = newItemsOutput .. itemName .. "\n"
        end
    end
end

local url = "https://discord.com/api/webhooks/1286177015690428416/BfVZiY9SfwsYm6BYKAJI4EvRYjaE5uv3kzQaXP1VFF-Lfoucr2eMnDWRGSoJBFKHw9LU"
local data = {
    ['embeds'] = {}
}

local output = clipboardOutput .. "\n" .. (newItemsFound and newItemsOutput or "No new items found.")
local messages = {}

local embedColor = 16744575 

while #output > 0 do
    local chunk = output:sub(1, 2000)
    table.insert(messages, chunk)
    output = output:sub(2001)
end

for i, message in ipairs(messages) do
    local embed = {
        ['title'] = "Item List Chunck " .. tostring(i),
        ['description'] = message,
        ['color'] = embedColor, 
        ['footer'] = {
            ['text'] = "Generated by the very best High Realms Player!"  
        }
    }
    table.insert(data['embeds'], embed)

    if #data['embeds'] == 10 then
        local jsonData = game:GetService("HttpService"):JSONEncode(data)

        local response = request({
            Url = url,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = jsonData
        })

        if response.Success then
            print("Message " .. tostring(i) .. " sent to Discord webhook!")
        else
            print("Error sending message " .. tostring(i) .. " to Discord webhook:")
            print(response.StatusCode)
            print(response.StatusMessage)
            print(response.Body)
        end

        data['embeds'] = {}
    end
end

if #data['embeds'] > 0 then
    local jsonData = game:GetService("HttpService"):JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = jsonData
    })

    if response.Success then
        print("Final message sent to Discord webhook!")
    else
        print("Error sending final message to Discord webhook:")
        print(response.StatusCode)
        print(response.StatusMessage)
        print(response.Body)
    end
end

print("Output sent to Discord webhook!")
end)

mobButton.MouseButton1Click:Connect(function()
local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local blockDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Block"):WaitForChild("DefinitionModules"):WaitForChild("Blocks")

local sections = {
    Mobs = "CommonModules.DefinitionModules.Mob.DefinitionModules",
}

local knownMobs = {
    Mobs = {
        "Flamelet", "Gizmo", "Slimegore", "GrimThorn", "Muncher", "Rattles", "Blue Flamelet", "Green Slime"
    }
}


local function getObjectByPath(root, path)
    local current = root
    for segment in string.gmatch(path, "[^.]+") do
        current = current:FindFirstChild(segment)
        if not current then
            warn("Could not find: " .. segment .. " in path: " .. path)
            return nil
        end
    end
    return current
end

local function detectNewFolders(root, knownFolders)
    local newFolders = {}
    for _, folder in ipairs(root:GetChildren()) do
        if folder:IsA("Folder") and not knownFolders[folder.Name] then
            newFolders[folder.Name] = true
        end
    end
    return newFolders
end

local clipboardOutput = ""
local newMobsOutput = ""
local newMobsFound = false
local newFoldersOutput = ""
local knownFolders = {}

for sectionName, path in pairs(sections) do
    local section = getObjectByPath(replicatedStorage, path)
    local knownMobsSet = {}
    local newMobs = {}
    local newFolders = {}

    if knownMobs[sectionName] then
        for _, MobName in ipairs(knownMobs[sectionName]) do
            knownMobsSet[MobName] = true
        end
    end
    
    if section then
        clipboardOutput = clipboardOutput .. "----- " .. sectionName .. " -----\n"
        local hasModules = false
        
        for _, moduleScript in pairs(section:GetChildren()) do
            if moduleScript:IsA("ModuleScript") then
                local moduleName = moduleScript.Name
                clipboardOutput = clipboardOutput .. moduleName .. "\n"
                hasModules = true
                
                if not knownMobsSet[moduleName] then
                    newMobs[moduleName] = true
                    newMobsFound = true
                end
            end
        end
        
        if not hasModules then
            clipboardOutput = clipboardOutput .. "No ModuleScripts found in " .. sectionName .. "\n"
        end

        newFolders = detectNewFolders(section, knownFolders)
        if next(newFolders) then
            newFoldersOutput = newFoldersOutput .. "----- New Folders in " .. sectionName .. " -----\n"
            for folderName in pairs(newFolders) do
                newFoldersOutput = newFoldersOutput .. folderName .. "\n"
            end
        end
    end
    
    if next(newMobs) then
        newMobsOutput = newMobsOutput .. "----- New Mobs in " .. sectionName .. " -----\n"
        for MobName in pairs(newMobs) do
            newMobsOutput = newMobsOutput .. MobName .. "\n"
        end
    end
end

local url = "https://discord.com/api/webhooks/1286226884304044032/YcCgY_ZC_7lxwjRpxvtf-0zfHrtVoEPeE6oLcblCxyq7tfjZez8_37-SxNv7Z94deV4W"
local data = {
    ['embeds'] = {}
}

local output = clipboardOutput .. "\n" .. (newMobsFound and newMobsOutput or "No new Mobs found.") .. "\n" .. newFoldersOutput
local messages = {}

local embedColor = 16744575 
local maxDescriptionLength = 4000

while #output > 0 do
    local chunk = output:sub(1, maxDescriptionLength)
    table.insert(messages, chunk)
    output = output:sub(maxDescriptionLength + 1)
end

local embed = {
    ['title'] = "Mob List",
    ['color'] = embedColor,
    ['footer'] = {
        ['text'] = "Generated by the very best High Realms Player!"  
    }
}

for i, message in ipairs(messages) do
    if i > 1 then
        local newEmbed = table.clone(embed)
        newEmbed['description'] = message
        table.insert(data['embeds'], newEmbed)

        if #data['embeds'] == 10 then
            local jsonData = game:GetService("HttpService"):JSONEncode(data)

            local response = request({
                Url = url,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })

            if response.Success then
                print("Message " .. tostring(i) .. " sent to Discord webhook!")
            else
                print("Error sending message " .. tostring(i) .. " to Discord webhook:")
                print(response.StatusCode)
                print(response.StatusMessage)
                print(response.Body)
            end

            data['embeds'] = {}
        end
    else
        embed['description'] = message
        table.insert(data['embeds'], embed)
    end
end

if #data['embeds'] > 0 then
    local jsonData = game:GetService("HttpService"):JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = jsonData
    })

    if response.Success then
        print("Final message sent to Discord webhook!")
    else
        print("Error sending final message to Discord webhook:")
        print(response.StatusCode)
        print(response.StatusMessage)
        print(response.Body)
    end
end

print("Output sent to Discord webhook!")
end)

badgeButton.MouseButton1Click:Connect(function()
local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local blockDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Block"):WaitForChild("DefinitionModules"):WaitForChild("Blocks")

local sections = {
    Badge = "CommonModules.DefinitionModules.Task.DefinitionModules.Badges",
 }

local knownBadges = {
    Badge = {
		"Play The Game",
"Reached Citadel",
"Reached Forest",
"Reached Mines",
"Reach 1M Coin Balance",
"Reach Player Level",
"Sit on the throne",
"Craft Recycled Blade",
"Collect 100 Flowers",
"Purchase Item",
"Defeat a Grimthorn",
"Cosmetics Change",
"Green Thumb",
"Slime Killer",
"Leap of Faith",
"The Wheel Turns",
"Farlight Crystals",
"I like Potatoes"
    }
}

local function getObjectByPath(root, path)
    local current = root
    for segment in string.gmatch(path, "[^.]+") do
        current = current:FindFirstChild(segment)
        if not current then
            warn("Could not find: " .. segment .. " in path: " .. path)
            return nil
        end
    end
    return current
end

local clipboardOutput = ""
local newBadgesOutput = ""
local newBadgesFound = false

for sectionName, path in pairs(sections) do
    local section = getObjectByPath(replicatedStorage, path)
    local knownBadgesSet = {}
    local newBadges = {}
    
    if knownBadges[sectionName] then
        for _, BadgeName in ipairs(knownBadges[sectionName]) do
            knownBadgesSet[BadgeName] = true
        end
    end
    
    if section then
        clipboardOutput = clipboardOutput .. "----- " .. sectionName .. " -----\n"
        local hasModules = false
        
        for _, moduleScript in pairs(section:GetChildren()) do
            if moduleScript:IsA("ModuleScript") then
                local moduleName = moduleScript.Name
                clipboardOutput = clipboardOutput .. moduleName .. "\n"
                hasModules = true
                
                if not knownBadgesSet[moduleName] then
                    newBadges[moduleName] = true
                    newBadgesFound = true
                end
            end
        end
        
        if not hasModules then
            clipboardOutput = clipboardOutput .. "No ModuleScripts found in " .. sectionName .. "\n"
        end
    end
    
    if next(newBadges) then
        newBadgesOutput = newBadgesOutput .. "----- New Badges in " .. sectionName .. " -----\n"
        for BadgeName in pairs(newBadges) do
            newBadgesOutput = newBadgesOutput .. BadgeName .. "\n"
        end
    end
end

local url = "https://discord.com/api/webhooks/1286233546566139957/CZflWIVH62v3_wslhZt0of-zuEpNAO09E8bnkulmU3rrufpY3QSZ2l3qp98UOc5OBCGl"
local data = {
    ['embeds'] = {}
}

local output = clipboardOutput .. "\n" .. (newBadgesFound and newBadgesOutput or "No new Badges found.")
local messages = {}

local embedColor = 16744575 

while #output > 0 do
    local chunk = output:sub(1, 2000)
    table.insert(messages, chunk)
    output = output:sub(2001)
end


for i, message in ipairs(messages) do
    local embed = {
        ['title'] = "Badge List Chunck " .. tostring(i),
        ['description'] = message,
        ['color'] = embedColor, 
        ['footer'] = {
            ['text'] = "Generated by the very best High Realms Player!"  
        }
    }
    table.insert(data['embeds'], embed)

    if #data['embeds'] == 10 then
        local jsonData = game:GetService("HttpService"):JSONEncode(data)

        local response = request({
            Url = url,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = jsonData
        })

        if response.Success then
            print("Message " .. tostring(i) .. " sent to Discord webhook!")
        else
            print("Error sending message " .. tostring(i) .. " to Discord webhook:")
            print(response.StatusCode)
            print(response.StatusMessage)
            print(response.Body)
        end

        data['embeds'] = {}
    end
end

if #data['embeds'] > 0 then
    local jsonData = game:GetService("HttpService"):JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = jsonData
    })

    if response.Success then
        print("Final message sent to Discord webhook!")
    else
        print("Error sending final message to Discord webhook:")
        print(response.StatusCode)
        print(response.StatusMessage)
        print(response.Body)
    end
end


print("Output sent to Discord webhook!")
end)

questButton.MouseButton1Click:Connect(function()
local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local taskDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Task"):WaitForChild("DefinitionModules")

local gettingStarted = taskDefinitionModules:FindFirstChild("Getting Started")
if gettingStarted then
    gettingStarted.Name = "GettingStarted"
else
end

wait("1")

local sections = {
    Quest = "CommonModules.DefinitionModules.Task.DefinitionModules.GettingStarted"
}

local knownQuests = {
    Quest = {
"Cobalt Forge III",
"Economic Growth",
"Farming Frenzy I",
"Island Expansion",
"Collecting Flowers",
"Gold Forge III",
"Forest Danger",
"A Day for Clay",
"Gold Forge II",
"Copper Forge III",
"Copper Forge I",
"Cobalt Forge II",
"Rising entrepreneur",
"Iron Forge II",
"Cobalt Forge I",
"Carrot Patch",
"The adventure begins",
"Iron Forge I",
"Woodland Wanderer",
"Dark Hollow",
"Iron Forge III",
"Mining Frenzy I",
"The Underlings",
"Gold Forge I",
"Copper Forge II",
"Greenhorn",
"Lumberjack I",
"Colored Clay",
"First Steps into the Depths",
"Stone Cold"
    }
}


local function getObjectByPath(root, path)
    local current = root
    for segment in string.gmatch(path, "[^.]+") do
        current = current:FindFirstChild(segment)
        if not current then
            warn("Could not find: " .. segment .. " in path: " .. path)
            return nil
        end
    end
    return current
end

local function detectNewFolders(root, knownFolders)
    local newFolders = {}
    for _, folder in ipairs(root:GetChildren()) do
        if folder:IsA("Folder") and not knownFolders[folder.Name] then
            newFolders[folder.Name] = true
        end
    end
    return newFolders
end

local clipboardOutput = ""
local newQuestsOutput = ""
local newQuestsFound = false
local newFoldersOutput = ""
local knownFolders = {}

for sectionName, path in pairs(sections) do
    local section = getObjectByPath(replicatedStorage, path)
    local knownQuestsSet = {}
    local newQuests = {}
    local newFolders = {}

    if knownQuests[sectionName] then
        for _, QuestName in ipairs(knownQuests[sectionName]) do
            knownQuestsSet[QuestName] = true
        end
    end
    
    if section then
        clipboardOutput = clipboardOutput .. "----- " .. sectionName .. " -----\n"
        local hasModules = false
        
        for _, moduleScript in pairs(section:GetChildren()) do
            if moduleScript:IsA("ModuleScript") then
                local moduleName = moduleScript.Name
                clipboardOutput = clipboardOutput .. moduleName .. "\n"
                hasModules = true
                
                if not knownQuestsSet[moduleName] then
                    newQuests[moduleName] = true
                    newQuestsFound = true
                end
            end
        end
        
        if not hasModules then
            clipboardOutput = clipboardOutput .. "No ModuleScripts found in " .. sectionName .. "\n"
        end

        newFolders = detectNewFolders(section, knownFolders)
        if next(newFolders) then
            newFoldersOutput = newFoldersOutput .. "----- New Folders in " .. sectionName .. " -----\n"
            for folderName in pairs(newFolders) do
                newFoldersOutput = newFoldersOutput .. folderName .. "\n"
            end
        end
    end
    
    if next(newQuests) then
        newQuestsOutput = newQuestsOutput .. "----- New Quests in " .. sectionName .. " -----\n"
        for QuestName in pairs(newQuests) do
            newQuestsOutput = newQuestsOutput .. QuestName .. "\n"
        end
    end
end

local url = "https://discord.com/api/webhooks/1286237119311904812/OmgiYH1xj8E7flMblohaQi2IhED_77E83Ox6sBZRinvNJGbrcFqM8YriPs6Hw5hYpeu9"
local data = {
    ['embeds'] = {}
}

local output = clipboardOutput .. "\n" .. (newQuestsFound and newQuestsOutput or "No new Quests found.") .. "\n" .. newFoldersOutput
local messages = {}

local embedColor = 16744575 
local maxDescriptionLength = 4000

while #output > 0 do
    local chunk = output:sub(1, maxDescriptionLength)
    table.insert(messages, chunk)
    output = output:sub(maxDescriptionLength + 1)
end

local embed = {
    ['title'] = "Quest List",
    ['color'] = embedColor,
    ['footer'] = {
        ['text'] = "Generated by the very best High Realms Player!"  
    }
}

for i, message in ipairs(messages) do
    if i > 1 then
        local newEmbed = table.clone(embed)
        newEmbed['description'] = message
        table.insert(data['embeds'], newEmbed)

        if #data['embeds'] == 10 then
            local jsonData = game:GetService("HttpService"):JSONEncode(data)

            local response = request({
                Url = url,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })

            if response.Success then
                print("Message " .. tostring(i) .. " sent to Discord webhook!")
            else
                print("Error sending message " .. tostring(i) .. " to Discord webhook:")
                print(response.StatusCode)
                print(response.StatusMessage)
                print(response.Body)
            end

            data['embeds'] = {}
        end
    else
        embed['description'] = message
        table.insert(data['embeds'], embed)
    end
end

if #data['embeds'] > 0 then
    local jsonData = game:GetService("HttpService"):JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = jsonData
    })

    if response.Success then
        print("Final message sent to Discord webhook!")
    else
        print("Error sending final message to Discord webhook:")
        print(response.StatusCode)
        print(response.StatusMessage)
        print(response.Body)
    end
end

print("Output sent to Discord webhook!")end)

closeButton.MouseButton1Click:Connect(function()
    screenGui.Enabled = false
end)

local function addGradientTo(object, color1, color2)
    local uiGradient = Instance.new("UIGradient")
    uiGradient.Color = ColorSequence.new(color1, color2)
    uiGradient.Parent = object
end

addGradientTo(itemButton, Color3.fromRGB(0, 170, 255), Color3.fromRGB(255, 255, 255))
addGradientTo(mobButton, Color3.fromRGB(255, 128, 0), Color3.fromRGB(255, 255, 255))
addGradientTo(badgeButton, Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 255))
addGradientTo(questButton, Color3.fromRGB(0, 255, 0), Color3.fromRGB(255, 255, 255))
